# `combinations` - Memory-efficient Cartesian products, combinations and permutation on collections.

 * [`CartesianCollection` - A view of a Cartesian-product collection over homogeneous collections.](#`CartesianCollection`---A-view-of-a-Cartesian-product-collection-over-homogeneous-collections.)
 * [`CombinationCollection` - A view of some combinations over a base collections.](#`CombinationCollection`---A-view-of-some-combinations-over-a-base-collections.)
 * [Authors](#Authors)

This module offers memory-efficient views on combinatoric collections.
Methods of the views create objects only when needed.
Moreover, produced objects during iterations are free to be collected and
their memory reused.

This enable these views and method to works with very combinatoric large collections.

When small combinatoric views need to be kept in memory (for fast access by example).
The `Collection::to_a` method and other related factories can be used to transform
the combinatoric views into extensive collections,

## `CartesianCollection` - A view of a Cartesian-product collection over homogeneous collections.

Therefore, this view *generates* all the sequences of elements constructed by associating
en element for each one of the original collections.

It is equivalent to doing nesting `for` for each collection.

~~~~
var xs = [1, 2, 3]
var ys = [8, 9]
var xys = new CartesianCollection[Int]([xs, ys])
assert xys.length == 6
assert xys.to_a == [[1,8], [1,9], [2,8], [2,9], [3,8], [3,9]]
~~~~

The pattern of the generate sequences produces a lexicographical order.

Because it is a generator, it is memory-efficient and the sequences are created only when needed.

Note: because it is a view, changes on the base collections are reflected on the view.

~~~~
assert xs.pop == 3
assert ys.pop == 9
assert xys.to_a == [[1,8], [2,8]]
~~~~

## `CombinationCollection` - A view of some combinations over a base collections.

This view *generates* some combinations and permutations on a collection.

By default, the generated sequences are combinations:

* each sequence has a length of `repeat`
* elements are in sorted order (see `are_sorted` for details)
* no repeated element (see `are_unique` for details)

~~~~
var xs = [1, 2, 3]
var cxs = new CombinationCollection[Int](xs, 2)
assert cxs.length == 3
assert cxs.to_a == [[1,2], [1,3], [2,3]]
~~~~

Other kind of combinations can be generated by tweaking the attributes `are_sorted` and `are_unique`.

* for permutation:

~~~~
cxs.are_sorted = false
cxs.are_unique = true
assert cxs.length == 6
assert cxs.to_a == [[1,2], [1,3], [2,1], [2,3], [3,1], [3,2]]
~~~~

* for combinations with replacement:

~~~~
cxs.are_sorted = true
cxs.are_unique = false
assert cxs.length == 6
assert cxs.to_a == [[1,1], [1,2], [1,3], [2,2], [2,3], [3,3]]
~~~~

* for product:

~~~~
cxs.are_sorted = false
cxs.are_unique = false
assert cxs.length == 9
assert cxs.to_a == [[1,1], [1,2], [1,3], [2,1], [2,2], [2,3], [3,1], [3,2], [3,3]]
~~~~

However, in the last case, a faster alternative is to use `CartesianCollection`:

~~~~
var cp = new CartesianCollection[Int]([xs] * 2)
assert cp.to_a == cxs.to_a
~~~~

As seen in the examples, the patterns of the generated sequences produce a lexicographical order.

Because it is a generator, it is memory-efficient and the sequences are created only when needed.

Note: because it is a view, changes on the base collection are reflected on the view.

~~~~
assert xs.pop == 3
cxs.are_sorted = true
cxs.are_unique = true
assert cxs.to_a == [[1,2]]
~~~~

## Authors

This project is maintained by **Jean Privat <jean@pryen.org>**.
