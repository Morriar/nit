# ast
# ~~~
# The `ast` module helps Python applications to process trees of the Python
# abstract syntax grammar.  The abstract syntax itself might change with
# each Python release; this module helps to find out programmatically what
# the current grammar looks like and allows modifications of it.
# An abstract syntax tree can be generated by passing `ast.PyCF_ONLY_AST` as
# a flag to the `compile()` builtin function or by using the `parse()`
# function from this module.  The result will be a tree of objects whose
# classes all inherit from `ast.AST`.
# A modified abstract syntax tree can be compiled into a Python code object
# using the built-in `compile()` function.
# Additionally various helper functions are provided that make working with
# the trees simpler.  The main intention of the helper functions and this
# module in general is to provide an easy to use interface for libraries
# that work tightly with the python syntax (template engines for example).
# :copyright: Copyright 2008 by Armin Ronacher.
# :license: Python License.
module ast

import builtins

class Raise
    super Stmt
    
end

class Param
    super Expr_context
    
end

class IsNot
    super Cmpop
    
end

class Suite
    super Mod
    
end

class Assert
    super Stmt
    
end

class Exec
    super Stmt
    
end

class Stmt
    super AST
    
end

class FloorDiv
    super Operator
    
end

class TryFinally
    super Stmt
    
end

class Not
    super Unaryop
    
end

class Lambda
    super Expr
    
end

class Mult
    super Operator
    
end

class Mod
    super AST
    
end

class And
    super Boolop
    
end

class Keyword
    super AST
    
end

class AugAssign
    super Stmt
    
end

class Yield
    super Expr
    
end

class BitAnd
    super Operator
    
end

class Div
    super Operator
    
end

class Or
    super Boolop
    
end

class FunctionDef
    super Stmt
    
end

class Gt
    super Cmpop
    
end

class Global
    super Stmt
    
end

class BoolOp
    super Expr
    
end

class Operator
    super AST
    
end

class Index
    super Slice
    
end

class Sub
    super Operator
    
end

class For
    super Stmt
    
end

class UnaryOp
    super Expr
    
end

class Invert
    super Unaryop
    
end

class DictComp
    super Expr
    
end

class LShift
    super Operator
    
end

class Ellipsis
    super Slice
    
end

class Print
    super Stmt
    
end

class Subscript
    super Expr
    
end

class BitOr
    super Operator
    
end

class ExceptHandler
    super Excepthandler
    
end

class ClassDef
    super Stmt
    
end

class Delete
    super Stmt
    
end

class NotEq
    super Cmpop
    
end

redef class Tuple
    
end

class Comprehension
    super AST
    
end

class LtE
    super Cmpop
    
end

class Pass
    super Stmt
    
end

class Eq
    super Cmpop
    
end

# A :class:`NodeVisitor` subclass that walks the abstract syntax tree and
# allows modification of nodes.
# The `NodeTransformer` will walk the AST and use the return value of the
# visitor methods to replace or remove the old node.  If the return value of
# the visitor method is ``None``, the node will be removed from its location,
# otherwise it is replaced with the return value.  The return value may be the
# original node in which case no replacement takes place.
# Here is an example transformer that rewrites all occurrences of name lookups
# (``foo``) to ``data['foo']``::
# class RewriteName(NodeTransformer):
# def visit_Name(self, node):
# return copy_location(Subscript(
# value=Name(id='data', ctx=Load()),
# slice=Index(value=Str(s=node.id)),
# ctx=node.ctx
# ), node)
# Keep in mind that if the node you're operating on has child nodes you must
# either transform the child nodes yourself or call the :meth:`generic_visit`
# method for the node first.
# For nodes that were part of a collection of statements (that applies to all
# statement nodes), the visitor may also return a list of nodes rather than
# just a single node.
# Usually you use the transformer like this::
# node = YourTransformer().visit(node)
class NodeTransformer
    super NodeVisitor
    
    redef fun generic_visit(node) is abstract
    
end

class Add
    super Operator
    
end

class Import
    super Stmt
    
end

class TryExcept
    super Stmt
    
end

class Store
    super Expr_context
    
end

class GtE
    super Cmpop
    
end

class AST
    
end

class Break
    super Stmt
    
end

class USub
    super Unaryop
    
end

class Cmpop
    super AST
    
end

class SetComp
    super Expr
    
end

class Del
    super Expr_context
    
end

class Str
    super Expr
    
end

class Expression
    super Mod
    
end

class Assign
    super Stmt
    
end

class Interactive
    super Mod
    
end

class Load
    super Expr_context
    
end

class ExtSlice
    super Slice
    
end

class Compare
    super Expr
    
end

redef class Set
    
end

class Attribute
    super Expr
    
end

class Num
    super Expr
    
end

redef class Dict
    
end

class Slice
    super AST
    
end

class Excepthandler
    super AST
    
end

class Lt
    super Cmpop
    
end

class Call
    super Expr
    
end

class Arguments
    super AST
    
end

class AugLoad
    super Expr_context
    
end

class Return
    super Stmt
    
end

class Boolop
    super AST
    
end

class Repr
    super Expr
    
end

redef class Sys
    
end

class ImportFrom
    super Stmt
    
end

# A node visitor base class that walks the abstract syntax tree and calls a
# visitor function for every node found.  This function may return a value
# which is forwarded by the `visit` method.
# This class is meant to be subclassed, with the subclass adding visitor
# methods.
# Per default the visitor functions for the nodes are ``'visit_'`` +
# class name of the node.  So a `TryFinally` node visit function would
# be `visit_TryFinally`.  This behavior can be changed by overriding
# the `visit` method.  If no visitor function exists for a node
# (return value `None`) the `generic_visit` visitor is used instead.
# Don't use the `NodeVisitor` if you want to apply changes to nodes during
# traversing.  For this a special visitor exists (`NodeTransformer`) that
# allows modifications.
class NodeVisitor
    
    # Called if no explicit visitor function exists for a node.
    fun generic_visit(node: Object) is abstract
    
    # Visit a node.
    fun visit(node: Object) is abstract
    
end

class UAdd
    super Unaryop
    
end

class With
    super Stmt
    
end

class Unaryop
    super AST
    
end

class NotIn
    super Cmpop
    
end

class RShift
    super Operator
    
end

class Name
    super Expr
    
end

class BinOp
    super Expr
    
end

class Expr
    super AST
    
end

redef class List
    
end

class Alias
    super AST
    
end

class Continue
    super Stmt
    
end

class BitXor
    super Operator
    
end

class Pow
    super Operator
    
end

class Is
    super Cmpop
    
end

class While
    super Stmt
    
end

redef class Module
    
end

class AugStore
    super Expr_context
    
end

class Expr_context
    super AST
    
end

class In
    super Cmpop
    
end

class If
    super Stmt
    
end

class GeneratorExp
    super Expr
    
end

class ListComp
    super Expr
    
end

class IfExp
    super Expr
    
end

