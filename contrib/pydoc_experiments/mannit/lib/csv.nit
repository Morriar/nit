# CSV parsing and writing.
# This module provides classes that assist in the reading and writing
# of Comma Separated Value (CSV) files, and implements the interface
# described by PEP 305.  Although many CSV files are simple to parse,
# the format is not formally defined by a stable specification and
# is subtle enough that parsing lines of a CSV file with something
# like line.split(",") is bound to fail.  The module supports three
# basic APIs: reading, writing, and registration of dialects.
# DIALECT REGISTRATION:
# Readers and writers support a dialect argument, which is a convenient
# handle on a group of settings.  When the dialect argument is a string,
# it identifies one of the dialects previously registered with the module.
# If it is a class or instance, the attributes of the argument are used as
# the settings for the reader or writer:
# class excel:
# delimiter = ','
# quotechar = '"'
# escapechar = None
# doublequote = True
# skipinitialspace = False
# lineterminator = '\r\n'
# quoting = QUOTE_MINIMAL
# SETTINGS:
# * quotechar - specifies a one-character string to use as the
# quoting character.  It defaults to '"'.
# * delimiter - specifies a one-character string to use as the
# field separator.  It defaults to ','.
# * skipinitialspace - specifies how to interpret whitespace which
# immediately follows a delimiter.  It defaults to False, which
# means that whitespace immediately following a delimiter is part
# of the following field.
# * lineterminator -  specifies the character sequence which should
# terminate rows.
# * quoting - controls when quotes should be generated by the writer.
# It can take on any of the following module constants:
# csv.QUOTE_MINIMAL means only when required, for example, when a
# field contains either the quotechar or the delimiter
# csv.QUOTE_ALL means that quotes are always placed around fields.
# csv.QUOTE_NONNUMERIC means that quotes are always placed around
# fields which do not parse as integers or floating point
# numbers.
# csv.QUOTE_NONE means that quotes are never placed around fields.
# * escapechar - specifies a one-character string used to escape
# the delimiter when quoting is set to QUOTE_NONE.
# * doublequote - controls the handling of quotes inside fields.  When
# True, two consecutive quotes are interpreted as one during read,
# and when writing, each quote character embedded in the data is
# written as two quotes
module csv

import re
import builtins

# CSV dialect
# The Dialect type records CSV parsing and generation options.
class Dialect
    
end

class DictWriter
    
    fun writerows(rowdicts: Object) is abstract
    
    fun writeheader is abstract
    
    init do end
    
    fun writerow(rowdict: Object) is abstract
    
    private fun private_dict_to_list(rowdict: Object) is abstract
    
end

class DictReader
    
    init do end
    
    fun iter is abstract
    
    fun next is abstract
    
end

# Describe the usual properties of Excel-generated CSV files.
class Excel
    super Dialect
    
end

# Describe the usual properties of Excel-generated TAB-delimited files.
class Excel_tab
    super Excel
    
end

redef class Sys
    
end

redef class Error
    
end

# "Sniffs" the format of a CSV file (i.e. delimiter, quotechar)
# Returns a Dialect object.
class Sniffer
    
    fun has_header(sample: Object) is abstract
    
    # Looks for text enclosed between two identical quotes
    # (the probable quotechar) which are preceded and followed
    # by the same character (the probable delimiter).
    # For example:
    # ,'some text',
    # The quote with the most wins, same with the delimiter.
    # If there is no quotechar the delimiter can't be determined
    # this way.
    private fun private_guess_quote_and_delimiter(delimiters, data: Object) is abstract
    
    init do end
    
    # The delimiter /should/ occur the same number of times on
    # each row. However, due to malformed data, it may not. We don't want
    # an all or nothing approach, so we allow for small variations in this
    # number.
    # 1) build a table of the frequency of each character on every line.
    # 2) build a table of frequencies of this frequency (meta-frequency?),
    # e.g.  'x occurred 5 times in 10 rows, 6 times in 1000 rows,
    # 7 times in 2 rows'
    # 3) use the mode of the meta-frequency to determine the /expected/
    # frequency for that character
    # 4) find out how often the character actually meets that goal
    # 5) the character that best meets its goal is the delimiter
    # For performance reasons, the data is evaluated in chunks, so it can
    # try and evaluate the smallest portion of the data possible, evaluating
    # additional chunks as necessary.
    private fun private_guess_delimiter(delimiters, data: Object) is abstract
    
    # Returns a dialect (or None) corresponding to the sample
    fun sniff(sample, delimiters: Object) is abstract
    
end

